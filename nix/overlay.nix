final: prev: {
  deno2nix = {
    # Import a deps.nix file generated by deno2nix CLI
    # Returns { sources, cache } where cache is ready-to-use npm cache
    # Usage: deno2nix.importDeps ./deps.nix
    importDeps = depsFile: final.callPackage depsFile {};

    # Build a Deno application
    # Usage: deno2nix.mkDenoApp { pname, version, src, deps, ... }
    mkDenoApp = {
      pname,
      version ? "0.0.0",
      src,                          # Source code directory
      deps,                         # Path to deps.nix
      denoJson,                     # Path to deno.json
      denoLock,                     # Path to deno.lock
      entrypoint ? "main.ts",       # Entry point relative to src
      permissions ? ["--allow-all"],
      # Hash of the DENO_DIR after fetching all deps
      # Required for reproducible builds. Get it by running:
      #   nix build .#<name>.denoCache 2>&1 | grep "got:"
      denoCacheHash ? null,
    }:
      let
        depsNix = final.callPackage deps {};
        perms = final.lib.concatStringsSep " " permissions;

        # Fixed-output derivation that fetches all dependencies
        denoCache = final.stdenv.mkDerivation {
          name = "${pname}-deno-cache";

          nativeBuildInputs = [ final.deno final.cacert ];

          # Must have source to know what to fetch
          inherit src;

          dontConfigure = true;
          dontFixup = true;

          buildPhase = ''
            export DENO_DIR="$out"
            export SSL_CERT_FILE="${final.cacert}/etc/ssl/certs/ca-bundle.crt"
            mkdir -p "$DENO_DIR"

            # Copy pre-fetched npm packages
            if [ -d "${depsNix.cache}/npm" ]; then
              cp -r ${depsNix.cache}/npm "$DENO_DIR/npm"
              chmod -R u+w "$DENO_DIR/npm"
            fi

            # Copy config files
            cp ${denoJson} deno.json
            cp ${denoLock} deno.lock

            # Cache all dependencies (fetches JSR packages)
            deno cache --node-modules-dir=false --config deno.json ${entrypoint}

            # Pre-fetch the deno compile runtime binary by compiling a dummy script
            echo 'console.log("hello")' > /tmp/dummy.ts
            deno compile --output /tmp/dummy /tmp/dummy.ts || true
            rm -f /tmp/dummy /tmp/dummy.ts
          '';

          installPhase = "true";

          # FOD settings
          outputHashMode = "recursive";
          outputHashAlgo = "sha256";
          outputHash = denoCacheHash;
        };
      in
      let
        # Build the raw binary first
        rawBinary = final.stdenv.mkDerivation {
          name = "${pname}-unwrapped";
          inherit src;

          nativeBuildInputs = [ final.deno ];

          dontConfigure = true;
          dontFixup = true;  # Don't patch the binary

          buildPhase = if denoCacheHash == null then ''
            echo "ERROR: denoCacheHash is required for mkDenoApp"
            echo ""
            echo "To get the hash, run:"
            echo "  nix build .#example.denoCache"
            echo ""
            echo "Then look for 'got:' in the error output and add it to your package.nix:"
            echo "  denoCacheHash = \"sha256-XXXX...\";"
            exit 1
          '' else ''
            runHook preBuild

            # Set up cache from FOD
            export DENO_DIR="$TMPDIR/deno"
            cp -r ${denoCache} "$DENO_DIR"
            chmod -R u+w "$DENO_DIR"

            # Copy config files
            cp ${denoJson} deno.json
            cp ${denoLock} deno.lock

            # Compile to standalone binary
            deno compile \
              --cached-only \
              --node-modules-dir=false \
              --config deno.json \
              ${perms} \
              --output ${pname} \
              ${entrypoint}

            runHook postBuild
          '';

          installPhase = ''
            mkdir -p $out/bin
            cp ${pname} $out/bin/${pname}
          '';
        };
      in
      # Wrap the binary in a FHS environment for NixOS compatibility
      (final.buildFHSEnv {
        name = pname;
        targetPkgs = pkgs: [ pkgs.stdenv.cc.cc.lib ];
        runScript = "${rawBinary}/bin/${pname}";

        meta = {
          mainProgram = pname;
        };
      }).overrideAttrs (old: {
        inherit version;
        passthru = (old.passthru or {}) // { inherit denoCache; unwrapped = rawBinary; };
      });
  };
}
